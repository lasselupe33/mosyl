/*
 * generated by Xtext 2.24.0
 */
package org.mdse.puzzle.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mdse.constructs.BooleanLiteral;
import org.mdse.constructs.BooleanVariable;
import org.mdse.constructs.ConstructsPackage;
import org.mdse.constructs.IntegerLiteral;
import org.mdse.constructs.IntegerVariable;
import org.mdse.constructs.StringLiteral;
import org.mdse.constructs.StringVariable;
import org.mdse.puzzle.Inputs;
import org.mdse.puzzle.Puzzle;
import org.mdse.puzzle.PuzzlePackage;
import org.mdse.puzzle.UnitTest;
import org.mdse.puzzle.UnitTestInput;
import org.mdse.puzzle.dsl.services.DSLGrammarAccess;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ConstructsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ConstructsPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case ConstructsPackage.BOOLEAN_VARIABLE:
				sequence_BooleanVariable(context, (BooleanVariable) semanticObject); 
				return; 
			case ConstructsPackage.INTEGER_LITERAL:
				sequence_IntergerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case ConstructsPackage.INTEGER_VARIABLE:
				sequence_IntegerVariable(context, (IntegerVariable) semanticObject); 
				return; 
			case ConstructsPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case ConstructsPackage.STRING_VARIABLE:
				sequence_StringVariable(context, (StringVariable) semanticObject); 
				return; 
			}
		else if (epackage == PuzzlePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PuzzlePackage.INPUTS:
				sequence_Inputs(context, (Inputs) semanticObject); 
				return; 
			case PuzzlePackage.PUZZLE:
				sequence_Puzzle(context, (Puzzle) semanticObject); 
				return; 
			case PuzzlePackage.UNIT_TEST:
				sequence_UnitTest(context, (UnitTest) semanticObject); 
				return; 
			case PuzzlePackage.UNIT_TEST_INPUT:
				sequence_UnitTestInput(context, (UnitTestInput) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralAccess().getValueBOOLEANTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns BooleanVariable
	 *     BooleanVariable returns BooleanVariable
	 *
	 * Constraint:
	 *     (name=ID value=BOOLEAN)
	 */
	protected void sequence_BooleanVariable(ISerializationContext context, BooleanVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.BOOLEAN_VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.BOOLEAN_VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanVariableAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBooleanVariableAccess().getValueBOOLEANTerminalRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Inputs returns Inputs
	 *
	 * Constraint:
	 *     variables+=Variable+
	 */
	protected void sequence_Inputs(ISerializationContext context, Inputs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns IntegerVariable
	 *     IntegerVariable returns IntegerVariable
	 *
	 * Constraint:
	 *     (name=ID value=REALINT)
	 */
	protected void sequence_IntegerVariable(ISerializationContext context, IntegerVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.INTEGER_VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.INTEGER_VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerVariableAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIntegerVariableAccess().getValueREALINTTerminalRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns IntegerLiteral
	 *     IntergerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=REALINT
	 */
	protected void sequence_IntergerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntergerLiteralAccess().getValueREALINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Puzzle returns Puzzle
	 *
	 * Constraint:
	 *     (name=STRING description=STRING inputs=Inputs? tests+=UnitTest+)
	 */
	protected void sequence_Puzzle(ISerializationContext context, Puzzle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns StringVariable
	 *     StringVariable returns StringVariable
	 *
	 * Constraint:
	 *     (name=ID value=STRING)
	 */
	protected void sequence_StringVariable(ISerializationContext context, StringVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ConstructsPackage.Literals.STRING_VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstructsPackage.Literals.STRING_VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringVariableAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStringVariableAccess().getValueSTRINGTerminalRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitTestInput returns UnitTestInput
	 *
	 * Constraint:
	 *     (variable=[Variable|ID] overwritingValue=Literal)
	 */
	protected void sequence_UnitTestInput(ISerializationContext context, UnitTestInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PuzzlePackage.Literals.UNIT_TEST_INPUT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PuzzlePackage.Literals.UNIT_TEST_INPUT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PuzzlePackage.Literals.UNIT_TEST_INPUT__OVERWRITING_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PuzzlePackage.Literals.UNIT_TEST_INPUT__OVERWRITING_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnitTestInputAccess().getVariableVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(PuzzlePackage.Literals.UNIT_TEST_INPUT__VARIABLE, false));
		feeder.accept(grammarAccess.getUnitTestInputAccess().getOverwritingValueLiteralParserRuleCall_2_0(), semanticObject.getOverwritingValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitTest returns UnitTest
	 *
	 * Constraint:
	 *     (inputs+=UnitTestInput* expected=Literal failedMessage=STRING?)
	 */
	protected void sequence_UnitTest(ISerializationContext context, UnitTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
